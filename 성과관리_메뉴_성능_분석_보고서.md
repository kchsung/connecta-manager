# 성과관리 메뉴 진입 지연 원인 분석 보고서

## 📋 요약

성과관리 메뉴 진입 시 발생하는 지연의 주요 원인은 **N+1 쿼리 문제**와 **캐시 미사용**입니다. 현재 구현은 각 데이터 조회마다 개별 쿼리를 실행하여 데이터베이스 호출 횟수가 기하급수적으로 증가합니다.

---

## 🔍 주요 문제점

### 1. N+1 쿼리 문제 (가장 심각)

**현재 구조:**
- 캠페인 목록 조회: **1회** 쿼리
- 각 캠페인마다 참여자 조회: **N회** 쿼리 (N = 캠페인 수)
- 각 참여자마다 성과 데이터 조회: **M회** 쿼리 (M = 참여자 수)

**총 쿼리 수: 1 + N + M**

**예시:**
- 캠페인 10개, 참여자 100명인 경우
- 총 쿼리: 1 + 10 + 100 = **111회**
- 각 쿼리가 평균 100ms 소요 시: **11.1초**

**문제 코드 위치:**
- `src/ui/performance_view_components.py:47-62` - 캠페인별 참여자 조회
- `src/ui/performance_view_components.py:215-227` - 참여자별 성과 데이터 조회

### 2. 캐시 미사용

**현재 상태:**
- `performance_view_components.py`: 캐시 없음 ❌
- `performance_report_components.py`: `@st.cache_data(ttl=300)` 사용 ✅

**영향:**
- 동일한 데이터를 매번 재조회
- 불필요한 데이터베이스 부하 증가

### 3. 대량 데이터 조회

**현재 구현:**
- `get_all_campaign_participations()`: `page_size=1000`으로 모든 데이터를 한 번에 조회
- 데이터가 많을 경우 메모리 사용량 증가 및 네트워크 지연

---

## 📊 성능 영향 분석

### 현재 쿼리 패턴

```
메뉴 진입
  ↓
1. get_campaigns() → 1회 쿼리
  ↓
2. for campaign in campaigns:
     get_all_campaign_participations(campaign_id) → N회 쿼리
  ↓
3. for participation in participations:
     get_performance_data_by_participation(participation_id) → M회 쿼리
```

### 예상 소요 시간 (데이터 규모별)

| 캠페인 수 | 참여자 수 | 쿼리 수 | 예상 시간 (100ms/쿼리) |
|---------|---------|---------|---------------------|
| 5       | 50      | 56      | 5.6초               |
| 10      | 100     | 111     | 11.1초              |
| 20      | 200     | 221     | 22.1초              |
| 50      | 500     | 551     | 55.1초              |

---

## ✅ 개선 방안

### 1. 배치 조회로 변경 (우선순위: 높음)

**현재 방식:**
```python
# 각 참여자마다 개별 쿼리
for participation in participations:
    content_data = db_manager.get_performance_data_by_participation(participation_id)
```

**개선 방식:**
```python
# 모든 참여자 ID를 한 번에 조회
participation_ids = [p["id"] for p in all_participations]
contents_by_participation = db_manager.get_contents_by_participation_ids(participation_ids)
```

**참고 구현:**
- `src/ui/ai_analysis_statistics/correlation_analysis.py:40-42`에서 이미 배치 조회 사용 중

### 2. 캐싱 적용 (우선순위: 높음)

**추가 필요:**
```python
@st.cache_data(ttl=300)
def get_all_participations_with_cache():
    """캠페인별 참여자 목록을 캐싱하여 조회"""
    ...

@st.cache_data(ttl=300)
def get_contents_by_participation_ids(participation_ids):
    """여러 참여자의 콘텐츠를 배치로 조회하고 캐싱"""
    ...
```

### 3. 데이터 조회 최적화 (우선순위: 중간)

**현재:**
- 모든 캠페인의 모든 참여자를 즉시 로드

**개선:**
- 사용자가 선택한 캠페인만 조회
- 또는 페이징/지연 로딩 적용

### 4. JOIN 쿼리 활용 (우선순위: 중간)

**개선:**
- Supabase에서 JOIN을 사용하여 한 번의 쿼리로 모든 데이터 조회
- 예: `campaign_influencer_participations`와 `campaign_influencer_contents`를 JOIN

---

## 🎯 권장 개선 순서

1. **즉시 적용 가능 (빠른 개선):**
   - 캐싱 적용 (`@st.cache_data`)
   - 배치 조회 함수 추가 및 사용

2. **단기 개선 (1-2주):**
   - 배치 조회 함수 구현
   - 성과 조회 탭에 배치 조회 적용

3. **중기 개선 (1개월):**
   - JOIN 쿼리로 통합
   - 인덱스 최적화 검토

---

## 📈 예상 개선 효과

### 개선 전
- 쿼리 수: 1 + N + M (예: 111회)
- 예상 시간: 11.1초 (캠페인 10개, 참여자 100명)

### 개선 후 (배치 조회 + 캐싱)
- 쿼리 수: 1 + N + 1 (예: 12회)
- 예상 시간: 1.2초 (첫 로드), 0.1초 (캐시 히트)
- **개선율: 약 90% 감소**

---

## 💡 추가 권장사항

1. **로딩 인디케이터 추가**
   - 사용자 경험 개선을 위해 데이터 로딩 중 표시

2. **에러 핸들링 강화**
   - 쿼리 실패 시 부분 데이터라도 표시

3. **성능 모니터링**
   - 쿼리 실행 시간 로깅
   - 데이터베이스 쿼리 로그 분석

---

## 📝 관련 파일

- `src/ui/performance_view_components.py` - 성과 조회 탭 (개선 필요)
- `src/ui/performance_report_components.py` - 성과 리포트 탭 (캐시 사용 중)
- `src/db/database.py` - 데이터베이스 매니저
- `src/supabase/simple_client.py` - Supabase 클라이언트
- `src/ui/ai_analysis_statistics/correlation_analysis.py` - 배치 조회 참고 예시

---

**작성일:** 2024년
**분석 대상:** 성과관리 메뉴 진입 시 성능 지연



